<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>贪吃蛇</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #000;
        color: #c8facc;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial,
          sans-serif;
      }

      .game-wrap {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }

      .hud {
        width: min(90vw, 500px);
        display: flex;
        justify-content: space-between;
        font-size: 18px;
        font-weight: 600;
      }

      canvas {
        width: min(90vw, 500px);
        height: min(90vw, 500px);
        image-rendering: pixelated;
        border: 2px solid #1a1a1a;
        background: #000;
      }

      .tip {
        font-size: 14px;
        opacity: 0.85;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="game-wrap">
      <div class="hud">
        <span>分数：<strong id="score">0</strong></span>
        <span id="status">按方向键开始</span>
      </div>
      <canvas id="game" width="500" height="500" aria-label="贪吃蛇游戏画布"></canvas>
      <div class="tip">方向键控制移动。撞墙或撞到自己会结束，按空格重新开始。</div>
    </div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const scoreEl = document.getElementById("score");
      const statusEl = document.getElementById("status");

      const gridCount = 20;
      const cellSize = canvas.width / gridCount;
      const speedMs = 120;

      const COLORS = {
        bg: "#000000",
        snake: "#22c55e",
        food: "#ef4444",
        grid: "#0b0b0b",
        text: "#bbf7d0"
      };

      let snake;
      let direction;
      let queuedDirection;
      let food;
      let score;
      let timer;
      let running;
      let started;
      let gameOver;

      function resetGame() {
        const center = Math.floor(gridCount / 2);
        snake = [
          { x: center, y: center },
          { x: center - 1, y: center },
          { x: center - 2, y: center }
        ];
        direction = { x: 1, y: 0 };
        queuedDirection = { x: 1, y: 0 };
        score = 0;
        running = false;
        started = false;
        gameOver = false;
        scoreEl.textContent = score;
        statusEl.textContent = "按方向键开始";
        placeFood();
        draw();
      }

      function placeFood() {
        while (true) {
          const x = Math.floor(Math.random() * gridCount);
          const y = Math.floor(Math.random() * gridCount);
          const onSnake = snake.some((part) => part.x === x && part.y === y);
          if (!onSnake) {
            food = { x, y };
            return;
          }
        }
      }

      function setDirection(next) {
        if (gameOver) return;

        const isReverse =
          next.x === -direction.x && next.y === -direction.y && started;

        if (!isReverse) {
          queuedDirection = next;
        }

        if (!started) {
          started = true;
          running = true;
          statusEl.textContent = "游戏进行中";
          loop();
        }
      }

      function loop() {
        clearTimeout(timer);
        if (!running) return;

        update();
        draw();

        timer = setTimeout(loop, speedMs);
      }

      function update() {
        direction = queuedDirection;

        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y
        };

        const hitWall =
          head.x < 0 || head.y < 0 || head.x >= gridCount || head.y >= gridCount;
        const hitSelf = snake.some((part) => part.x === head.x && part.y === head.y);

        if (hitWall || hitSelf) {
          running = false;
          gameOver = true;
          statusEl.textContent = "游戏结束，按空格重开";
          return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score += 1;
          scoreEl.textContent = score;
          placeFood();
        } else {
          snake.pop();
        }
      }

      function drawGrid() {
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 1;
        for (let i = 1; i < gridCount; i++) {
          const p = i * cellSize;
          ctx.beginPath();
          ctx.moveTo(p, 0);
          ctx.lineTo(p, canvas.height);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(0, p);
          ctx.lineTo(canvas.width, p);
          ctx.stroke();
        }
      }

      function drawCell(x, y, color, padding = 2) {
        ctx.fillStyle = color;
        ctx.fillRect(
          x * cellSize + padding,
          y * cellSize + padding,
          cellSize - padding * 2,
          cellSize - padding * 2
        );
      }

      function draw() {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawGrid();
        drawCell(food.x, food.y, COLORS.food, 4);

        snake.forEach((part, i) => {
          drawCell(part.x, part.y, COLORS.snake, i === 0 ? 1 : 2);
        });

        if (gameOver) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.55)";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = COLORS.text;
          ctx.textAlign = "center";
          ctx.font = "bold 42px sans-serif";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 8);
          ctx.font = "20px sans-serif";
          ctx.fillText("按空格重新开始", canvas.width / 2, canvas.height / 2 + 28);
        }
      }

      window.addEventListener("keydown", (e) => {
        switch (e.key) {
          case "ArrowUp":
            e.preventDefault();
            setDirection({ x: 0, y: -1 });
            break;
          case "ArrowDown":
            e.preventDefault();
            setDirection({ x: 0, y: 1 });
            break;
          case "ArrowLeft":
            e.preventDefault();
            setDirection({ x: -1, y: 0 });
            break;
          case "ArrowRight":
            e.preventDefault();
            setDirection({ x: 1, y: 0 });
            break;
          case " ":
          case "Spacebar":
            if (gameOver) {
              resetGame();
            }
            break;
          default:
            break;
        }
      });

      resetGame();
    </script>
  </body>
</html>
